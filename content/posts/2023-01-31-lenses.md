---
title: "Lenses"
date: 2023-01-25
draft: false
---
# The Problem

Modern IT systems have historically increased their internal complexity over time. Ever since the early days, engineers built larger and increasingly bespoke systems, layering abstractions on top of each other in intricate trade-offs to achieve other system properties such as high availability or simply to fulfil business needs. Complexity is neither inevitable nor an end in itself. It is a necessary byproduct of the way the IT industry implements solutions.

This forced engineers, the actual humans interacting with machines, to develop increasingly complex [mental models](https://en.wikipedia.org/wiki/Mental_model) to be able to reason about, operate and develop further the systems within their responsibility. During incidents, a mismatch between the mental model of the engineer and some part of the actual systems's state or structure takes up most of the overall incident duration. In other cases, this mismatch might be the cause of an incident or security vulnerability in the first place. Understanding a system is often identified with parsing information and forming a mental model of the particular detail in question while it is actually only necessary preliminary work.[^1]

# Incomplete Solutions

The consistent increase in system complexity has not been met with a similar investment in secondary systems, helping engineers understand the actual, primary systems they operate. They developed and refined monitoring, alarming solutions and various other visualization systems over the years, but they never really caught up with the primary system's complexity, while the effort necessary to build an ad-hoc mental model of a given system keeps increasing.

When we look at modern science fiction TV shows or movies, we often see people operating systems with complexities not unlike current IT systems. However, the average TV watcher has to be able to follow the story and for that needs to develop their own minimal mental model of the system's state. Because of this, visualisation of the complex sci-fi systems is vastly different from the everyday visualization of actual systems of similar complexity. Its language is more obvious, more direct and simply better designed. It is designed towards quick intuitive clarity. We make it easy for TV watchers but do not invest in the same principle when actual systems depend on humans understanding them.

Visualization of current day IT systems has not kept up with the complexity of the actual systems because engineers have gotten used to building up a mental image of the system from the visualisation and then working from there, not expecting the visualisation itself being ready to be consumed and be reasoned about. We think coming to a basic understanding of a given system on the spot is part of the job while it could be delegated to machines, if only we taught them how to help us better.

Also, in most cases the secondary systems are maintained separately from the primary systems. Documentation is written before or after changes, but not automatically by the same mechanism implementing the change. Monitoring configuration is edited manually per individual resource instead of building libraries of reusable building blocks. Even in cases where e.g. monitoring configuration is automatically created, this is almost never true for all the other visualization systems.

To close the gap between the systems and their visualisation as a tool to their understanding, we must see visualization not as separate system but derive it from the same source as the actual system and also make the representation as easily understandable as possible, i.e. minimize the effort to build a mental model. 

# A Model

Basically, IT systems consist of some kind of structure, the actual parts that make up the specific system. This can be a database consisting of a set of virtual machines with volumes attached, living in a subnet. The structures are derived via some kind of mechanism from a machine-readable definition, for example created by a pipeline running Terraform applying a manifest. Over time, the operation of these structures will lead to some kind of state, not meaning the contents of the database but the amount of memory used, disk space used, etc. at a given time. Also, we usually have a set of assumptions about our structure, e.g. we expect the database's free disk space to be below a certain threshold for the database to function properly.

In most organizations, the following secondary systems are implemented and operated to operate any given primary system:

* monitoring
* metrics
* documentation

All of them are basically some kind of visualisation of the primary system to help human engineers construct a mental model of the primary system. They are all visualisations of the same thing. They are simply different lenses on the same system.

Visualizing only the bare structure itself is called documentation. \
Visualizing the structure's state at a given time is called metrics. \
Visualizing whether assumptions apply to the current state is called monitoring.

All of it is some kind of visualization.

![Diagram of concepts](/images/lenses-fig0.png)

# Proposed Solution

I propose engineers start to understand monitoring, metrics and documentation as only slightly differing visualizations of the same primary system, as lenses on the same object. The visualizations should be developed as part of the structure element they represent.

1. Describe and edit the definition in a machine-readable, versionable way. 
    * Add explanatory annotations to certain units of the definition. Make them available as metadata of the generated structure.
    * Add assumptions of state during the structure's lifecycle.
2. Generate all your structures from this definition by a reproducible, idempotent mechanism.
3. Generate all visual representation from this definition by a reproducible, idempotent mechanism.
4. Make it a top priority to create visual, intuitively understandable representations of your structure and its behavior. Design this so mental model and structure (including its behavior) overlap as much as possible.


# Example

> 1. Describe and edit the definition in a machine-readable, versionable way. 

Suppose we want to build a minimal system consisting of two virtual machines, a web application and its database, running on a virtualization host. We create a Git repository that holds Terraform manifests describing all of the elements (structures) for this, instances, volumes, subnets, etc.

> * Add explanatory annotations to certain units of the definition. Make them available as metadata of the generated structure.

We add annotations to the Terraform manifests that get rendered to metadata fields of the actual cloud instances. Think short human-readable comments about the object they belong to. Also, they get included in the documentation that is rendered and appear in the monitoring diagrams.

> * Add assumptions of state during the structure's lifecycle.

We add annotations to the individual parts of the manifests, e.g. add an annotation describing at what level of used disk space a system is not expected to function properly anymore.

The system's state has to be measured, everything else can be derived from the definition. So the definition should include everything we know about the system before operating it.

> 2. Generate all your structures from this definition by a reproducible, idempotent mechanism.

We add pipelines to the Git project in GitLab that use Terraform to provision the virtual machines from a pipeline.

> 3. Generate all visual representation from this definition by a reproducible, idempotent mechanism.

Make that pipeline also add representations of all structures to relevant systems.
Automatically update the operational documentation in the wiki including the architectural diagram. Automatically add or modify the structure's settings in the metrics collection system and modify thresholds in the monitoring system

> 4. Make it a top priority to create visual, intuitively understandable representations of your structure and its behavior. Design this so mental model and structure (including its behavior) overlap as much as possible.

Work on how to visualize structures that you use repeatedly. Decide on a standard way to visualize a subnet and its current state. Implement that decision in code and use that code to render your system's visualizations.
We use Terraform modules to abstract away recurring patterns into modules, e.g. defining what components a standard virtual machine consists of (volumes, memory, CPU cores, etc.) and build applications from these building blocks. We ensure that every module includes a visual representation. A module for a virtual machine includes definitions for visualizing it in the monitoring system, thus all virtual machines look the same in the monitoring system. We can rely on that pale green octagon being a virtual machine. A high system load could slowly turn the machine red, thus making it easy for an engineer to pinpoint one overloaded instance in a cluster just by looking at it's visualization in the monitoring system. A network graph of communicating HTTP services could express the percentage of 4xx replies as edges turning red and the number of requests as the edge's size. Whatever feels intuitive for the engineers that need to think about the system. They do not have to pull the data and check hypotheses, they can use the visualization itself to reason about the system.

Over time we develop a library of modules that we use to build systems and render their representation into secondary visualization systems. People start to argue what colors should represent what states, showing they offloaded their mental modelling to the visualization. As the representation is only rendered from a common source, changing the look of something to better map to mental models is handled in a merge request and discussed between engineers just as any other review would be.

# Conclusion

Modern IT systems and their representations engineers use to build mental models necessary for operating them have diverged over time. Systems should be built from standardized building blocks that should be expected to include not just definitions how to produce the structures necessary to form the system but also definitions how to represent the structures in various visualization systems such as monitoring and documentation.

When structures and their representations are derived from the same source, they are developed in sync. Visualizations are crucial in understanding and operating IT systems, they must be treated as first-class configuration items. This would move engineering focus towards a more abstract yet also more intuitive and clearer view of the systems and its behaviors.

Instead of trying to piece together mental models from disparate partial views, we should invest effort in developing solutions to understand systems intuitively.

[^1]: Experience will tremendously increase speed of this process, thus forming a major source of pride in individual engineers.